{% set tcp = cookiecutter.L4_protocol == "TCP" -%}
{% set udp = cookiecutter.L4_protocol == "UDP" -%}
// Generated by binpac_quickstart

#pragma once

#include "events.bif.h"

{% if tcp %}
#include "analyzer/protocol/tcp/TCP.h"
{% elif udp %}
#include "analyzer/protocol/udp/UDP.h"
{% endif %}
#include "{{ cookiecutter.protocol_name }}_pac.h"

using namespace analyzer::{{ cookiecutter.project_namespace }}_{{ cookiecutter.protocol_name }};

class {{ cookiecutter.protocol_name }}_Analyzer
{% if tcp %}
: public tcp::TCP_ApplicationAnalyzer {
{% elif udp %}
: public analyzer::Analyzer {
{% endif %}
public:
	{{ cookiecutter.protocol_name }}_Analyzer(Connection* conn);
	virtual ~{{ cookiecutter.protocol_name }}_Analyzer();

	// Overriden from Analyzer.
	virtual void Done();
	{% if tcp %}
	virtual void DeliverStream(int len, const u_char* data, bool orig);
	virtual void Undelivered(uint64 seq, int len, bool orig);

	// Overriden from tcp::TCP_ApplicationAnalyzer.
	virtual void EndpointEOF(bool is_orig);
	{% elif udp %}
	virtual void DeliverPacket(int len, const u_char* data, bool orig,
					uint64 seq, const IP_Hdr* ip, int caplen);
	{% endif %}

	static analyzer::Analyzer* InstantiateAnalyzer(Connection* conn)
		{ return new {{ cookiecutter.protocol_name }}_Analyzer(conn); }

protected:
	binpac::{{ cookiecutter.protocol_name }}::{{ cookiecutter.protocol_name }}_Conn* interp;
	{% if tcp %}
	bool had_gap;
	{% endif %}
};
