{% set tcp = cookiecutter.L4_protocol == "TCP" -%}
{% set udp = cookiecutter.L4_protocol == "UDP" -%}
// Generated by binpac_quickstart

#ifndef ANALYZER_PROTOCOL_{{ cookiecutter.protocol_name|upper }}_{{ cookiecutter.protocol_name|upper }}_H
#define ANALYZER_PROTOCOL_{{ cookiecutter.protocol_name|upper }}_{{ cookiecutter.protocol_name|upper }}_H

#include "events.bif.h"

{% if tcp %}
#include "analyzer/protocol/tcp/TCP.h"
{% elif udp %}
#include "analyzer/protocol/udp/UDP.h"
{% endif %}
#include "{{ cookiecutter.protocol_name|lower }}_pac.h"

namespace analyzer { namespace {{ cookiecutter.protocol_name }} {

class {{ cookiecutter.protocol_name|upper }}_Analyzer
{% if tcp %}
: public tcp::TCP_ApplicationAnalyzer {
{% elif udp %}
: public analyzer::Analyzer {
{% endif %}
public:
	{{ cookiecutter.protocol_name|upper }}_Analyzer(Connection* conn);
	virtual ~{{ cookiecutter.protocol_name|upper }}_Analyzer();

	// Overriden from Analyzer.
	virtual void Done();
	{% if tcp %}
	virtual void DeliverStream(int len, const u_char* data, bool orig);
	virtual void Undelivered(uint64 seq, int len, bool orig);

	// Overriden from tcp::TCP_ApplicationAnalyzer.
	virtual void EndpointEOF(bool is_orig);
	{% elif udp %}
	virtual void DeliverPacket(int len, const u_char* data, bool orig,
					uint64 seq, const IP_Hdr* ip, int caplen);
	{% endif %}

	static analyzer::Analyzer* InstantiateAnalyzer(Connection* conn)
		{ return new {{ cookiecutter.protocol_name|upper }}_Analyzer(conn); }

protected:
	binpac::{{ cookiecutter.protocol_name|upper }}::{{ cookiecutter.protocol_name|upper }}_Conn* interp;
	{% if tcp %}
	bool had_gap;
	{% endif %}
};

} } // namespace analyzer::* 

#endif
